
MÉTHODE (lab1/data/file_concerter.py) 
============================================

1) Objet
--------
Convertir chaque entrée (un mot prononcé) composée de X trames (frames) en une
représentation de taille fixe utilisable par un MLP.
	- On fixe le nombre de trames à N (par défaut: N ∈ {40, 50, 60}).
	- On conserve uniquement les paramètres statiques: 12 coefficients par trame.
	- Dimension finale: N × 12 (donc 480/600/720 valeurs pour N=40/50/60).
	- Chaque ligne de sortie reste étiquetée: <label>: <N×12 valeurs>.


2) Format des fichiers d’entrée
-------------------------------
Chaque ligne est une entrée (un exemple) au format:
	<label>: v1 v2 v3 ... vM
	- Le label est un chiffre suivi de « : » (ex: 8:).
	- Les vi sont des réels (float).


3) Interprétation des données
-----------------------------
Les vi représentent des trames concaténées (flatten).
On suppose que le vecteur peut être découpé en T trames de C coefficients:
	M = T × C

Le script essaie de détecter C parmi {39, 26, 13}:
	- C = 39 (cas MFCC “complet”)
		12 statiques + Es + 12 dynamiques (Δ) + Ed + 12 accélérations (ΔΔ) + Edd
		Indices (0-based):
			Es  = 12
			Ed  = 25
			Edd = 38

	- C = 26
		12 statiques + Es + 12 dynamiques (Δ) + Ed

	- C = 13
		12 statiques + Es

Remarque:
	- Si M = 1560 et C = 39, alors T = 40.
	  Dans ce cas, l’entrée a déjà 40 trames; la sélection par énergie conserve
	  simplement ces 40 trames (pas de réduction).


4) Définition du score d’énergie (Es)
------------------------------------
On utilise Es (énergie statique) comme score d’importance d’une trame.
Pour une trame f (vecteur de longueur C), on prend:
	score(f) = |f[Es_index]|
Le |.| (valeur absolue) rend la sélection robuste aux signes.


5) Sélection par énergie (réduction X → N)
-----------------------------------------
Soit une séquence de T trames f0..f(T-1).
On veut sélectionner N trames “les plus significatives”.

Étapes:
	1) Calculer l’énergie de chaque trame:
		ei = |fi[Es_index]|
	2) Prendre les N indices ayant les plus grandes énergies.
	3) IMPORTANT: trier ces indices par ordre croissant pour conserver l’ordre
	   temporel (on garde la structure du mot).

Cas T < N:
	- On garde toutes les trames.
	- On complète (padding) avec des trames nulles (zéros) jusqu’à N trames.


6) Extraction des paramètres statiques + vectorisation
------------------------------------------------------
Après sélection/padding, on a exactement N trames de longueur C.
	- On conserve uniquement les 12 premières valeurs de chaque trame:
		stat(fi) = fi[0:12]
	- On concatène les N blocs de 12 valeurs (flatten):
		X_out = [stat(f0), stat(f1), ..., stat(f(N-1))]


7) Sorties générées
-------------------
Le script peut générer plusieurs fichiers de sortie d'un coup.
Par défaut, il produit 3 versions:
	40_<nom_source>.txt
	50_<nom_source>.txt
	60_<nom_source>.txt

Format du fichier de sortie (une ligne par exemple):
	<label>: x1 x2 ... x(N×12)
Ce qui fait (1 + N×12) “tokens” si on compte le label comme 1 token.


8) Utilisation
--------------
A) Lancer la conversion (recommandé)
	python -m lab1.data.file_concerter

B) Entrées par défaut
	Les fichiers d'entrée attendus sont dans le même dossier que le script:
		data_train.txt, data_vc.txt, data_test.txt

C) Dépôt des sorties
	Pour chaque source, la sortie est écrite dans le même répertoire que la source
	(ex: 40_data_train.txt).


============================================================
ANNEXE - CONVERSION DES LABELS (ONE-HOT) ET REGLE MAX
============================================================

Ce bloc documente 2 méthodes utilitaires utilisées dans le laboratoire 1:
	1) convert_label(label, nb_sorties)
	2) fonction_max(valeurs)


1) Methode: convert_label(label, nb_sorties)
--------------------------------------------
Rôle
	Convertit un label (classe) en vecteur binaire (one-hot) de taille nb_sorties.

Signature
	convert_label(label: int, nb_sorties: int) -> list[int]

Règles
	A) Cas spécial (nb_sorties = 10, chiffres)
		- ordre des classes = 1,2,3,4,5,6,7,8,9,0
		- donc 0 est encodé sur la dernière position
		- labels acceptés: 0..9 (sinon: erreur)

	B) Cas générique (nb_sorties != 10)
		- accepte des labels 0..nb_sorties-1 (0-based)
		- accepte aussi 1..nb_sorties (1-based)
		- si le label est hors plage, on replie par modulo:
			idx = label % nb_sorties
		  (objectif: toujours produire un vecteur de la taille demandée)

Algorithme (pseudo)
	1. Valider nb_sorties >= 1
	2. Si nb_sorties == 10:
		- valider 0 <= label <= 9
		- idx = 9 si label == 0, sinon idx = label - 1
		- vec = [0]*10 ; vec[idx] = 1 ; retourner vec
	3. Sinon:
		- si 0 <= label < nb_sorties: idx = label
		- sinon si 1 <= label <= nb_sorties: idx = label - 1
		- sinon: idx = label % nb_sorties
		- vec = [0]*nb_sorties ; vec[idx] = 1 ; retourner vec

Exemples
	- convert_label(1, 10)  -> [1,0,0,0,0,0,0,0,0,0]
	- convert_label(9, 10)  -> [0,0,0,0,0,0,0,0,1,0]
	- convert_label(0, 10)  -> [0,0,0,0,0,0,0,0,0,1]
	- convert_label(0, 3)   -> [1,0,0]
	- convert_label(2, 3)   -> [0,0,1]
	- convert_label(8, 5)   -> idx = 8%5 = 3 -> [0,0,0,1,0]


2) Methode: fonction_max(valeurs)
---------------------------------
Rôle
	Convertit une liste analogique (sorties du réseau) en liste binaire (0/1)
	en appliquant la règle MAX (argmax).

Signature
	fonction_max(valeurs: Sequence[float]) -> list[int]

Règle MAX
	- l'élément de plus grande valeur devient 1
	- tous les autres deviennent 0
	- en cas d'égalité, le premier maximum reçoit le 1 (tie-break argmax)

Algorithme (pseudo)
	1. Si valeurs est vide: retourner []
	2. max_index = index de la plus grande valeur (premier max si égalité)
	3. Retourner un vecteur binaire de même taille:
		vec[i] = 1 si i == max_index sinon 0

Exemples
	- fonction_max([0.12, -0.32, 0.52, 0.42]) -> [0,0,1,0]
	- fonction_max([]) -> []
	- fonction_max([1.0, 1.0, 0.0]) -> [1,0,0]


3) References (ou dans le code)
-------------------------------
Definitions
	- convert_label: voir lab1/loader.py
	- fonction_max: voir lab1/service.py

Utilisation (exemples)
	- Tests rapides: lab1/smoke_test.py
	- Orchestration (generalisation / affichage): lab1/lanceur.py
	- Backprop (appel ponctuel): lab1/backpp.py

